(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob:
      'FileReader' in self &&
      'Blob' in self &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  /* Build a destructive iterator for the value list */
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        /* IE 10-11 can't handle a DataView body. */
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  /* HTTP methods whose capitalization should be normalized */
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    /* Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
     * https://tools.ietf.org/html/rfc7230#section-3.2 */
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = self.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.onabort = function() {
        reject(new exports.DOMException('Aborted', 'AbortError'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          /* DONE (success or failure) */
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!self.fetch) {
    self.fetch = fetch;
    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

!function(e,n){"object"==typeof exports&&"undefined"!=typeof module?n():"function"==typeof define&&define.amd?define(n):n()}(0,function(){"use strict";function e(e){var n=this.constructor;return this.then(function(t){return n.resolve(e()).then(function(){return t})},function(t){return n.resolve(e()).then(function(){return n.reject(t)})})}function n(){}function t(e){if(!(this instanceof t))throw new TypeError("Promises must be constructed via new");if("function"!=typeof e)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=undefined,this._deferreds=[],u(e,this)}function o(e,n){for(;3===e._state;)e=e._value;0!==e._state?(e._handled=!0,t._immediateFn(function(){var t=1===e._state?n.onFulfilled:n.onRejected;if(null!==t){var o;try{o=t(e._value)}catch(f){return void i(n.promise,f)}r(n.promise,o)}else(1===e._state?r:i)(n.promise,e._value)})):e._deferreds.push(n)}function r(e,n){try{if(n===e)throw new TypeError("A promise cannot be resolved with itself.");if(n&&("object"==typeof n||"function"==typeof n)){var o=n.then;if(n instanceof t)return e._state=3,e._value=n,void f(e);if("function"==typeof o)return void u(function(e,n){return function(){e.apply(n,arguments)}}(o,n),e)}e._state=1,e._value=n,f(e)}catch(r){i(e,r)}}function i(e,n){e._state=2,e._value=n,f(e)}function f(e){2===e._state&&0===e._deferreds.length&&t._immediateFn(function(){e._handled||t._unhandledRejectionFn(e._value)});for(var n=0,r=e._deferreds.length;r>n;n++)o(e,e._deferreds[n]);e._deferreds=null}function u(e,n){var t=!1;try{e(function(e){t||(t=!0,r(n,e))},function(e){t||(t=!0,i(n,e))})}catch(o){if(t)return;t=!0,i(n,o)}}var c=setTimeout;t.prototype["catch"]=function(e){return this.then(null,e)},t.prototype.then=function(e,t){var r=new this.constructor(n);return o(this,new function(e,n,t){this.onFulfilled="function"==typeof e?e:null,this.onRejected="function"==typeof n?n:null,this.promise=t}(e,t,r)),r},t.prototype["finally"]=e,t.all=function(e){return new t(function(n,t){function o(e,f){try{if(f&&("object"==typeof f||"function"==typeof f)){var u=f.then;if("function"==typeof u)return void u.call(f,function(n){o(e,n)},t)}r[e]=f,0==--i&&n(r)}catch(c){t(c)}}if(!e||"undefined"==typeof e.length)throw new TypeError("Promise.all accepts an array");var r=Array.prototype.slice.call(e);if(0===r.length)return n([]);for(var i=r.length,f=0;r.length>f;f++)o(f,r[f])})},t.resolve=function(e){return e&&"object"==typeof e&&e.constructor===t?e:new t(function(n){n(e)})},t.reject=function(e){return new t(function(n,t){t(e)})},t.race=function(e){return new t(function(n,t){for(var o=0,r=e.length;r>o;o++)e[o].then(n,t)})},t._immediateFn="function"==typeof setImmediate&&function(e){setImmediate(e)}||function(e){c(e,0)},t._unhandledRejectionFn=function(e){void 0!==console&&console&&console.warn("Possible Unhandled Promise Rejection:",e)};var l=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw Error("unable to locate global object")}();"Promise"in l?l.Promise.prototype["finally"]||(l.Promise.prototype["finally"]=e):l.Promise=t});


/**
 * Array.prototype.forEach() polyfill
 * @author Chris Ferdinandi
 * @license MIT
 */
if (!Array.prototype.forEach) {
	Array.prototype.forEach = function (callback, thisArg) {
		thisArg = thisArg || window;
		for (var i = 0; i < this.length; i++) {
			callback.call(thisArg, this[i], i, this);
		}
	};
}

if (window.NodeList && !NodeList.prototype.forEach) {
	NodeList.prototype.forEach = Array.prototype.forEach;
}
(function () {

	if (typeof window.CustomEvent === "function") return false;

	function CustomEvent(event, params) {
		params = params || { bubbles: false, cancelable: false, detail: null };
		var evt = document.createEvent('CustomEvent');
		evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
		return evt;
	}

	window.CustomEvent = CustomEvent;
})();
const store = {

	key: "storeData",

	data: {
		firstName: null,
		lastName: null,
		mobile: null,
		email: null,
		zipCode: null,
		gid: null
	},

	save: function () {
		localStorage.setItem(store.key, JSON.stringify(store.data));
	},

	init: function () {
		if (localStorage.getItem(store.key) !== null) {
			store.data = JSON.parse(localStorage.getItem(store.key));
		}
	}
}
store.init();
const inventory = {

	// name of form to use
	formID: "inventoryFilter",

	// cache make/model data
	data: null,

	// cache bodystyle data
	bsData: null,

	// cache bodyStyle data
	bodyStyle: null,

	// cache the split url arguments
	urlArgs: {},

	// store referenced form elements
	elements: {},

	// state
	state: {},

	// result page
	page: 1,

	/**
	 * handlers
	 *
	 * container for methods that handle event driven form actions
	 */
	handlers: {
		bodyStyle: function () {
			inventory.buildMake();
			inventory.buildModel();
		},
		makes: function () {
			inventory.buildModel();
		},
		zipCode: function () {
			let zipCode;
			if (inventory.elements.zipCode.value != null) {
				zipCode = inventory.elements.zipCode.value;
			} else {
				zipCode = '';
			}
			inventory.elements.zipCode.classList.remove("form-error");
			if (zipCode.match(/^[0-9]{5}$/)) {
				let url = "https://cars.automoblog.net/api/inventory/getzipcode?zipcode=" + zipCode;
				inventory.doGet(url)
					.then(function (isValid) {
						if (!isValid) {
							inventory.elements.zipCode.classList.add("form-error");
						} else {
							inventory.updateVehicleCount();
						}
					})
			} else {
				inventory.elements.zipCode.classList.add("form-error");
			}
		},
		conditionNew: function () {
			inventory.buildMake();
			inventory.buildModel();
		},
		conditionUsed: function () {
			inventory.buildMake();
			inventory.buildModel();
		},
		submit: function () {
			// Get the GID
			let sellerDtxID = inventory.elements.GID.value;

			let errorCount = document.querySelectorAll(".form-error");
			if (errorCount.length == 0) {
				//inventory.elements.submit.classList.add("loading");
				inventory.elements.inventoryFilter.classList.add("loading");
				inventory.elements.submit.disabled = true;

				// Remove lazy loading div to prevent constant inventory URL calls through lazy loading
				let lazyDiv = document.querySelector(".lazy-load-trigger");
				if (lazyDiv) {
					lazyDiv.remove();
				}

				let make = inventory.elements.makes.value;
				let model = inventory.elements.models.value;
				let zipCode = inventory.elements.zipCode.value;
				let conditionNew = inventory.elements.conditionNew.checked;
				let conditionUsed = inventory.elements.conditionUsed.checked;
				let bodyStyle = inventory.elements.bodyStyle.value;
				let inventoryType = inventory.urlArgs.inventorytype ? inventory.urlArgs.inventorytype : null;
				let mtCertified = inventory.urlArgs.mtcertified
					? inventory.urlArgs.mtcertified
					: inventory.elements.mtCertified
						? inventory.elements.mtCertified.checked
						: false;
				let sortOption = inventory.elements.sortOptions ? inventory.elements.sortOptions.value : null;
				let referralDataEncoded = inventory.elements.referralDataEncoded.value;

				// This is only used currently for CarsForSale, so it is assumed that if this field is not checked, we only want MT Certified
				if (inventory.elements.allInventory) {
					inventoryType = inventory.elements.allInventory.checked ? "dtxandppc" : "ppc";
				}

				let url = "https://cars.automoblog.net/api/inventory/getinventoryresults?make=" + make + "&model=" + model + "&zipCode=" + zipCode + "&isNew=" + conditionNew + "&isUsed=" + conditionUsed + "&bodyStyle=" + bodyStyle + "&inventoryType=" + inventoryType + "&mtCertified=" + mtCertified + "&sortOption=" + sortOption + "&referralDataEncoded=" + referralDataEncoded;


				//Returns inventory
				inventory.doGet(url)
					.then(function (data) {
						let inventoryResults = document.querySelector("#inventoryResults");
						inventoryResults.innerHTML = data;
						inventory.elements.submit.disabled = false;
						//inventory.elements.submit.classList.remove("loading");
						inventory.elements.inventoryFilter.classList.remove("loading");

						// Check for CarsForSale/MotorTrendInventory
						//  By only using querySelector we should be able to only hit the first one.
						//  No real good way of determining this without changing the API a bit
						const noMTCertified = document.querySelector(".no-mt-certified");
						if (noMTCertified && mtCertified && mtCertified != "false") {
							noMTCertified.classList.remove("hide");
						}

						//inventory.setURL();

						let event = new CustomEvent("inventory-result-pageload");
						window.dispatchEvent(event);

						inventory.lazyLoadInit();
					});
			}
		},
	},

	/**
	 * fillSelect
	 *
	 * helper function to fill select lists
	 *
	 * @param {any} title
	 * @param {any} target
	 * @param {any} data
	 * @param {any} property
	 */
	fillSelect: function (title, target, data, defaultValue) {
		data = data || null; // Thanks ie11 :(
		defaultValue = defaultValue || null; // Thanks ie11 :(
		target.options.length = 0;
		let selectDefault = document.createElement("option");
		selectDefault.text = title;
		selectDefault.value = "";
		target.add(selectDefault);
		if (data === null || data === undefined || data.length == 0) {
			target.disabled = true;
		} else {
			data.sort();
			data.forEach(function (element) {
				let option = document.createElement("option");
				let keyValue = element.split("|");
				option.text = keyValue[0];
				option.value = keyValue[1];
				target.add(option);
			});

			if (defaultValue !== null && defaultValue != 0) {
				let options = target.querySelectorAll("option");
				options.forEach(function (option) {
					if (option.value.toLowerCase() == defaultValue.toLowerCase()) {
						target.value = option.value;
					}

					//van -> full-size
					if (defaultValue.toLowerCase() == "van") {
						target.value = "Full-Size";
					}

					//Truck -> pickup
					if (defaultValue.toLowerCase() == "truck") {
						target.value = "Pickup";
					}

					//crossover -> wagon
					if (defaultValue.toLowerCase() == "crossover / wagon") {
						target.value = "Wagon";
					}
				});
			}
			target.disabled = false;
		}
	},

	/**
	 * updateVehicleCount
	 *
	 *
	 * Update vehicle count on search button
	 */
	updateVehicleCount: function () {
		inventory.setState();
		//inventory.elements.submit.classList.add("loading");
		inventory.elements.inventoryFilter.classList.add("loading");
		inventory.elements.submit.disabled = true;
		let make = inventory.elements.makes.value;
		let model = inventory.elements.models.value;
		let zip = inventory.elements.zipCode.value;
		let conditionNew = inventory.elements.conditionNew.checked;
		let conditionUsed = inventory.elements.conditionUsed.checked;
		let bodyStyle = inventory.elements.bodyStyle.value;
		let sellerDtxID = inventory.elements.GID.value;
		let inventoryType = inventory.urlArgs.inventorytype ? inventory.urlArgs.inventorytype : null;
		let mtCertified = inventory.urlArgs.mtcertified
			? inventory.urlArgs.mtcertified
			: inventory.elements.mtCertified
				? inventory.elements.mtCertified.checked
				: false;

		// This is only used currently for CarsForSale, so it is assumed that if this field is not checked, we only want MT Certified
		if (inventory.elements.allInventory) {
			inventoryType = inventory.elements.allInventory.checked ? "dtxandppc" : "ppc";
		}

		let url = "https://cars.automoblog.net/api/inventory/getvehiclecount?make=" + make + "&model=" + model + "&zipCode=" + zip + "&sellerDtxID=" + sellerDtxID + "&bodyStyle=" + bodyStyle + "&isNew=" + conditionNew + "&isUsed=" + conditionUsed + "&mtCertified=" + mtCertified + "&inventoryType=" + inventoryType;

		inventory.doGet(url)
			.then(function (data) {
				let option = document.createElement("option");
				option.text = `Search ${data.vehicleCount} results`;
				option.value = `Search ${data.vehicleCount} results`;
				if (sellerDtxID !== "0000-4294") {
					inventory.elements.submit.innerText = option.text;
				} else {
					let searchTitle = document.querySelector(".search-title");
					if (bodyStyle) {
						const bodyStyleText = inventory.elements.bodyStyle.options[inventory.elements.bodyStyle.selectedIndex].text;
						searchTitle.innerHTML = `<b>${bodyStyleText}s</b> Near ${data.location.City},  <b>${data.vehicleCount}</b> vehicles near ${zip}`;
					} else if (make) {
						searchTitle.innerHTML = `<b>${make} ${model || ''}</b> Near ${data.location.City}, <b>${data.vehicleCount}</b> vehicles near ${zip}`;
					} else {
						searchTitle.innerHTML = `<b>${data.vehicleCount}</b> vehicles near ${zip}`;
					}
				}
				//inventory.elements.submit.classList.remove("loading");
				inventory.elements.inventoryFilter.classList.remove("loading");
				inventory.elements.submit.disabled = false;
			})
			.catch(function (error) {
				console.log(error);
			});
	},

	/**
	 * doGet
	 *
	 * Helper function to make ajax GET requests
	 *
	 * @param {any} endpoint
	 */
	doGet: function (endpoint) {
		return fetch(endpoint)
			.then(function (response) {
				const contentType = response.headers.get("content-type");
				if (contentType && contentType.indexOf("application/json") !== -1) {
					return response.json().then(function (data) {
						return JSON.parse(data);

					});
				} else {
					return response.text().then(function (html) {
						return html;
					});
				}
			});
	},

	/**
	 * setState
	 *
	 * set current form state. Used to build form with params.
	 *
	 * @param {any} useURLCache
	 */
	setState: function (useURLCache) {
		useURLCache = useURLCache || false;
		let state = {};
		if (useURLCache) {
			state.bodyStyle = inventory.urlArgs.bodystyle || "";
			state.make = inventory.urlArgs.make || "";
			state.model = inventory.urlArgs.model || "";
			state.zipCode = inventory.urlArgs.zipcode || "";
			state.isNew = (inventory.urlArgs.isnew == "true" || inventory.urlArgs.isnew === undefined) ? true : false;
			state.isUsed = (inventory.urlArgs.isused == "true" || inventory.urlArgs.isnew === undefined) ? true : false;
		} else {
			state.bodyStyle = inventory.elements.bodyStyle.value;
			state.make = inventory.elements.makes.value;
			state.model = inventory.elements.models.value;
			state.zipCode = inventory.elements.zipCode.value;
			state.isNew = inventory.elements.conditionNew.checked;
			state.isUsed = inventory.elements.conditionUsed.checked;
		}
		inventory.state = state;
	},

	buildBodyStyle: function () {
		let bodyStyleData = [];
		inventory.bsData.forEach(function (bodyStyle) {
			let value = bodyStyle + "|" + bodyStyle;
			switch (bodyStyle) {
				case "Chassis":
					value = null;
					break;
				case "Full-Size":
					value = "Van" + "|" + bodyStyle;
					break;
				case "Pickup":
					value = "Truck" + "|" + bodyStyle;
					break;
				case "Wagon":
					value = "Crossover / Wagon" + "|" + bodyStyle;
					break;
			}

			if (value !== null) {
				bodyStyleData.push(value);
			}
		});

		inventory.fillSelect("Select Body Style", inventory.elements.bodyStyle, bodyStyleData, inventory.state.bodyStyle);
	},

	buildMake: function () {
		let makeData = [];
		inventory.data.forEach(function (make) {
			let isIncluded = true;
			let settingBodyStyle = (inventory.elements.bodyStyle.value != 0) ? inventory.elements.bodyStyle.value : false;
			let settingNew = inventory.elements.conditionNew.checked;
			let settingUsed = inventory.elements.conditionUsed.checked;
			let makeAllBodyStyles = make.BodyStylesNew.concat(make.BodyStylesUsed);
			let makeNewBodyStyles = make.BodyStylesNew;
			let makeUsedBodyStyles = make.BodyStylesUsed;
			let makeIsNew = make.HasGaqSupport;
			let makeIsUsed = make.HasInventoryData;
			let makeIsNewUsed = (makeIsNew || makeIsUsed) ? true : false;

			if (settingBodyStyle && settingNew && settingUsed) {
				if (!makeIsNewUsed) {
					isIncluded = false;
				}
				if (!makeAllBodyStyles.includes(settingBodyStyle)) {
					isIncluded = false;
				}
			} else if (settingBodyStyle && settingNew) {
				if (!makeIsNew) {
					isIncluded = false;
				}
				if (!makeNewBodyStyles.includes(settingBodyStyle)) {
					isIncluded = false;
				}
			} else if (settingBodyStyle && settingUsed) {
				if (!makeIsUsed) {
					isIncluded = false;
				}
				if (!makeUsedBodyStyles.includes(settingBodyStyle)) {
					isIncluded = false;
				}
			} else if (settingNew && settingUsed) {
				if (!makeIsNewUsed) {
					isIncluded = false;
				}
			} else if (settingNew) {
				if (!makeIsNew) {
					isIncluded = false;
				}
			} else if (settingUsed) {
				if (!makeIsUsed) {
					isIncluded = false;
				}
			}

			if (isIncluded) {
				makeData.push(make.Make + "|" + make.Make);
			}
		});
		inventory.fillSelect("Select Make", inventory.elements.makes, makeData, inventory.state.make);
	},

	buildModel: function () {
		let modelData = [];
		inventory.data.forEach(function (make) {
			if (make.Make == inventory.elements.makes.value) {
				make.Models.forEach(function (model) {
					let isIncluded = true;
					let settingBodyStyle = (inventory.elements.bodyStyle.value != 0) ? inventory.elements.bodyStyle.value : false;
					let settingNew = inventory.elements.conditionNew.checked;
					let settingUsed = inventory.elements.conditionUsed.checked;
					let modelAllBodyStyles = model.BodyStyles;
					let modelIsNew = model.HasGaqSupport;
					let modelIsUsed = model.HasInventoryData;
					let modelIsNewUsed = (modelIsNew || modelIsUsed) ? true : false;

					if (settingBodyStyle && settingNew && settingUsed) {
						if (!modelIsNewUsed) {
							isIncluded = false;
						}
						if (!modelAllBodyStyles.includes(settingBodyStyle)) {
							isIncluded = false;
						}
					} else if (settingBodyStyle && settingNew) {
						if (!modelIsNew) {
							isIncluded = false;
						}
						if (!modelAllBodyStyles.includes(settingBodyStyle)) {
							isIncluded = false;
						}
					} else if (settingBodyStyle && settingUsed) {
						if (!modelIsUsed) {
							isIncluded = false;
						}
						if (!modelAllBodyStyles.includes(settingBodyStyle)) {
							isIncluded = false;
						}
					} else if (settingNew && settingUsed) {
						if (!modelIsNewUsed) {
							isIncluded = false;
						}
					} else if (settingNew) {
						if (!modelIsNew) {
							isIncluded = false;
						}
					} else if (settingUsed) {
						if (!modelIsUsed) {
							isIncluded = false;
						}
					}

					if (isIncluded) {
						modelData.push(model.Model + "|" + model.Model);
					}
				});
			}
		});
		inventory.fillSelect("Select Model", inventory.elements.models, modelData, inventory.state.model);
	},

	setURL: function () {
		let make = inventory.elements.makes.value;
		let model = inventory.elements.models.value;
		let zipCode = inventory.elements.zipCode.value;
		let conditionNew = inventory.elements.conditionNew.checked;
		let conditionUsed = inventory.elements.conditionUsed.checked;
		let bodyStyle = inventory.elements.bodyStyle.value;
		let mtCertified = inventory.urlArgs.mtcertified
			? inventory.urlArgs.mtcertified
			: inventory.elements.mtCertified
				? inventory.elements.mtCertified.checked
				: false;
		let referralDataEncoded = inventory.elements.referralDataEncoded.value;

		bodyStyle = (bodyStyle == "") ? 0 : bodyStyle;
		make = (make == "") ? 0 : make;
		model = (model == "") ? 0 : model;

		var makeUrl = make == 0 ? "" : `/make-${make}`;
		var modelUrl = model == 0 ? "" : `/model-${model}`;
		var bodyUrl = bodyStyle == 0 ? "" : `/bodystyle-${bodyStyle}`;
		var mtCertifiedUrl = mtCertified == "false" && inventory.elements.mtCertified === undefined ? "" : `/mtcertified-${mtCertified}`;
		var referralDataEncodedUrl = referralDataEncoded === "" ? "" : `/referralDataEncoded-${referralDataEncoded}`;

		let updateurl;
		if (mtCertified != "undefined") {
			updateurl = `/search${makeUrl}${modelUrl}/zipcode-${zipCode}/isnew-${conditionNew}/isused-${conditionUsed}${bodyUrl}${mtCertifiedUrl}${referralDataEncodedUrl}`;
		} else {
			updateurl = `/search${makeUrl}${modelUrl}/zipcode-${zipCode}/isnew-${conditionNew}/isused-${conditionUsed}${bodyUrl}${referralDataEncodedUrl}`;
		}

		history.replaceState(null, null, updateurl);
	},

	lazyLoadInit: function () {
		let options = {
			root: null,
			rootMargin: "0px",
			threshold: 1.0
		};
		let observer = new IntersectionObserver((entries, options) => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					console.log("lazy-loading");
					let trigger = document.querySelector(".lazy-load-trigger");
					inventory.page++;
					let make = inventory.elements.makes.value;
					let model = inventory.elements.models.value;
					let zipCode = inventory.elements.zipCode.value;
					let conditionNew = inventory.elements.conditionNew.checked;
					let conditionUsed = inventory.elements.conditionUsed.checked;
					let bodyStyle = inventory.elements.bodyStyle.value;
					let inventoryType = inventory.urlArgs.inventorytype ? inventory.urlArgs.inventorytype : null;
					let mtCertified = inventory.urlArgs.mtcertified
						? inventory.urlArgs.mtcertified
						: inventory.elements.mtCertified
							? inventory.elements.mtCertified.checked
							: false;
					let sortOption = inventory.elements.sortOptions ? inventory.elements.sortOptions.value : null;
					let referralDataEncoded = inventory.elements.referralDataEncoded.value;

					// This is only used currently for CarsForSale, so it is assumed that if this field is not checked, we only want MT Certified
					if (inventory.elements.allInventory) {
						inventoryType = inventory.elements.allInventory.checked ? "dtxandppc" : "ppc";
					}

					let url = "https://cars.automoblog.net/api/inventory/getinventoryresults?make=" + make + "&model=" + model + "&zipCode=" + zipCode + "&isNew=" + conditionNew + "&isUsed=" + conditionUsed + "&bodyStyle=" + bodyStyle + "&inventoryType=" + inventoryType + "&mtCertified=" + mtCertified + "&sortOption=" + sortOption + "&pageNumber=" + inventory.page + "&referralDataEncoded=" + referralDataEncoded;
					inventory.doGet(url)
						.then(function (data) {
							trigger.classList.remove("lazy-load-trigger");
							let inventoryResults = document.querySelector("#inventoryResults");
							let newElement = document.createElement("div");
							newElement.innerHTML = data;
							inventoryResults.insertAdjacentElement("beforeend", newElement);
							inventory.lazyLoadInit();
						})
						.catch(function (error) {
							console.log(error);
						});
				}
			});
		});
		observer.observe(document.querySelector(".lazy-load-trigger"));
	},

	/**
	 * init
	 *
	 * Initialize inventory object
	 */
	init: function () {
		let parsedUrl = window.location.pathname.split('/');
		let clickSubmit = false;

		if (parsedUrl[1] == "used_cars") {
			if (parsedUrl.length > 3) {
				let urlMake = parsedUrl[3].charAt(0).toUpperCase() + parsedUrl[3].slice(1);
				inventory.urlArgs.make = urlMake;
			}

			if (parsedUrl.length > 4) {
				let urlModel = parsedUrl[4].charAt(0).toUpperCase() + parsedUrl[4].slice(1);
				inventory.urlArgs.model = urlModel;
			}

			clickSubmit = true;
			inventory.setState(true);

			// do stuff for motortrend current feeder

		} else {
			// store URL params
			parsedUrl.forEach(function (urlArguments) {
				try {
					var currentParameter = [];

					/////////
					var firstDash = urlArguments.indexOf("-");

					// 1
					currentParameter[0] = urlArguments.slice(0, firstDash);
					// 2
					currentParameter[1] = urlArguments.slice(firstDash + 1);

					if (currentParameter.length == 2) {
						clickSubmit = true;
						var key = currentParameter[0].toLowerCase();
						var value = decodeURIComponent(currentParameter[1]);
						inventory.urlArgs[key] = value;
					}

					if (currentParameter.includes("bodystyle")) {

						document.querySelector(".search-btn.make-model").classList.remove("active");
						document.querySelector(".make-model-group").classList.add("hide");

						document.querySelector(".search-btn.bodystyle").classList.add("active");
						document.querySelector(".bodystyle-group").classList.remove("hide");

						//inventory.elements.makes.value = undefined;
						//inventory.elements.makes.selectedIndex = 0;
						//inventory.elements.models.value = undefined;
						//inventory.elements.models.selectedIndex = 0;
						//inventory.elements.models.disabled = true;
					}
				}
				catch (e) {
					console.log("could not parse the arg")
				}
			});
			inventory.setState(true);
		}

		// process form and set up custom events
		let active = document.querySelector("#" + inventory.formID);
		if (active !== null) {
			let elements = document.querySelectorAll("[data-form-element]");
			elements.forEach(function (element) {
				let name = element.getAttribute("id");
				inventory.elements[name] = element;
				let event = new CustomEvent(name);
				let action = element.getAttribute("data-action");

				if (action !== null) {
					inventory.elements[name].addEventListener(action, function () {
						window.dispatchEvent(event);
					});
				}

				if (inventory.handlers.hasOwnProperty(name)) {
					window.addEventListener(name, inventory.handlers[name]);
				}
			});

			// prevent traditional form submit
			inventory.elements.inventoryFilter.addEventListener("submit", function (event) {
				event.preventDefault();
			});

			// Precaution in the case that the user clicks enter after entering their zipCode
			// instead of clicking the update button
			inventory.elements.inventoryFilter.addEventListener("keyup", function (event) {
				if (event.keyCode === 13) {
					inventory.updateVehicleCount();
				}
			});

			// set isNew based on URL
			if (!(inventory.urlArgs.isNew === undefined)) {
				inventory.elements.conditionNew.checked = (inventory.urlArgs.isNew == 'true');
			}

			// set isUsed based on URL
			if (!(inventory.urlArgs.isUsed === undefined)) {
				inventory.elements.conditionUsed.checked = (inventory.urlArgs.isUsed == 'true');
			}

			// set up promise array
			var ajaxRequestPromises = [];

			// get vehicles (promise)
			ajaxRequestPromises.push(inventory.doGet("https://cars.automoblog.net/api/inventory/GetVehicles")
				.then(function (data) {
					inventory.data = data;
				})
				.catch(function (error) {
					console.log(error);
				})
			);

			// get bodystyles (promise)
			ajaxRequestPromises.push(inventory.doGet("https://cars.automoblog.net/api/inventory/GetBodyStyles")
				.then(function (data) {
					inventory.bsData = data;
				})
				.catch(function (error) {
					console.log(error);
				})
			);

			// get zipcode (promise)
			ajaxRequestPromises.push(inventory.doGet("https://cars.automoblog.net/api/inventory/GetZipCode")
				.then(function (data) {
					if (data != null) {
						inventory.elements.zipCode.value = data;
					}
					else {
						inventory.elements.zipCode.value = ""
					}
				})
			);

			// submit form once all values have been filled from ajax calls
			Promise.all(ajaxRequestPromises)
				.then(function () {
					// build forms
					inventory.buildBodyStyle();
					inventory.buildMake();
					inventory.buildModel();
					inventory.elements.conditionNew.checked = inventory.state.isNew;
					inventory.elements.conditionUsed.checked = inventory.state.isUsed;
					if (inventory.state.zipCode != "") {
						inventory.elements.zipCode.value = inventory.state.zipCode;
					}

					// set up vehicle count listeners
					inventory.updateVehicleCount();
					window.addEventListener("makes", inventory.updateVehicleCount);
					window.addEventListener("models", inventory.updateVehicleCount);
					window.addEventListener("bodyStyle", inventory.updateVehicleCount);
					window.addEventListener("conditionNew", inventory.updateVehicleCount);
					window.addEventListener("conditionUsed", inventory.updateVehicleCount);
					if (clickSubmit) {
						inventory.handlers.submit();
					}
				});
		}
	}
}

inventory.init();
const leadform = {

	// name of form to use
	formID: "leadForm",

	// store referenced form elements
	elements: {},

	/**
	 * handlers
	 *
	 * container for methods that handle event driven form actions
	 */
	handlers: {
		firstName: function () {
			if (leadform.elements.firstName.value == "") {
				leadform.elements.firstName.classList.add("form-error");
			} else {
				leadform.elements.firstName.classList.remove("form-error");
			}
		},
		lastName: function () {
			if (leadform.elements.lastName.value == "") {
				leadform.elements.lastName.classList.add("form-error");
			} else {
				leadform.elements.lastName.classList.remove("form-error");
			}
		},
		mobile: function () {
			if (leadform.elements.mobile.value == "") {
				leadform.elements.mobile.classList.add("form-error");
			} else {
				leadform.elements.mobile.classList.remove("form-error");
			}
		},
		email: function () {
			if (leadform.elements.email.value == "") {
				leadform.elements.email.classList.add("form-error");
			} else {
				leadform.elements.email.classList.remove("form-error");
			}
		},
		submit: function () {
			let isValid = true;
			let validate = [
				leadform.elements.firstName,
				leadform.elements.lastName,
				leadform.elements.mobile,
				leadform.elements.email,
				leadform.elements.zip,

			];
			validate.forEach(function (element) {
				if (element.value == "") {
					element.classList.add("form-error");
					isValid = false;
				}
			})

			if (isValid) {
				leadform.elements.submit.classList.add("loading");
				let make = leadform.elements.make.value;
				let model = leadform.elements.model.value;
				let zip = leadform.elements.zipCode.value;
				let fName = leadform.elements.firstName.value;
				let lName = leadform.elements.lastName.value;
				let email = leadform.elements.email.value;
				let phone = leadform.elements.mobile.value;
				let gid = leadform.elements.GID.value;
				let year = leadform.elements.Year.value;
				let vin = leadform.elements.VIN.value;
				let trim = leadform.elements.Trim.value;
				let slot = leadform.elements.slot.value;
				let referralDataEncoded = leadform.elements.referralDataEncoded.value;

				store.data.firstName = fName;
				store.data.lastName = lName;
				store.data.email = email;
				store.data.mobile = phone;
				store.data.zipCode = zip;
				store.data.gid = gid;
				store.save();

				let path = "https://cars.automoblog.net/api/inventory/submitlead?make=" + make +
					"&model=" + model + "&zipCode=" + zip + "&fName=" + fName + "&lName=" + lName +
					"&email=" + email + "&phone=" + phone + "&gid=" + gid + "&vin=" + vin +
					"&year=" + year + "&trim=" + trim + "&slot=" + slot + "&referralDataEncoded=" + referralDataEncoded; // + "reservationID";

				inventory.doGet(path)
					.then(function () {
						window.location.href = "/ThankYouPage/" + year + "/" + make + "/" + model + "/" + vin + "/" + zip + "/" + slot + "/" + referralDataEncoded;
						leadform.elements.submit.classList.remove("loading");
					});
			}
		}
	},

	/**
	 * doGet
	 *
	 * Helper function to make ajax GET requests
	 *
	 * @param {any} endpoint
	 */
	doGet: function (endpoint) {
		return fetch(endpoint)
			.then(function (response) {
				const contentType = response.headers.get("content-type");
				if (contentType && contentType.indexOf("application/json") !== -1) {
					return response.json().then(function (data) {
						return JSON.parse(data);

					});
				} else {
					return response.text().then(function (html) {
						return html;
					});
				}
			});
	},

	/**
	 * init
	 *
	 * Initialize leadform object
	 */
	init: function () {
		let active = document.querySelector("#" + leadform.formID);
		if (active !== null) {
			let elements = document.querySelectorAll("[data-form-element]");
			elements.forEach(function (element) {
				let name = element.getAttribute("id");

				leadform.elements[name] = element;
				let event = new CustomEvent(name);
				let action = element.getAttribute("data-action");
				if (action !== null) {
					leadform.elements[name].addEventListener(action, function () {
						window.dispatchEvent(event);
					});
				}
				if (leadform.handlers.hasOwnProperty(name)) {
					window.addEventListener(name, leadform.handlers[name]);
				}
			});
		}

		let legals = document.querySelectorAll("[data-legal-target]");
		legals.forEach(function (legal) {
			legal.addEventListener("click", function (e) {
				e.preventDefault();
				let target = this.getAttribute("data-legal-target");
				let element = document.getElementById(target);
				element.classList.add("active");
			});
		});

		let legalClose = document.querySelectorAll(".legal-close");
		legalClose.forEach(function (close) {
			close.addEventListener("click", function () {
				document.querySelector(".modal-container.active").classList.remove("active");
			});
		});
	}
}

leadform.init();
const imageCarousel = {

	display: null,

	init: function () {
		let carousel = document.querySelector(".vdp-image-carousel");
		if (carousel !== null) {
			imageCarousel.display = carousel.querySelector("img");
			let images = carousel.querySelectorAll(".vdp-ic-image");
			images[0].classList.add("active");
			images.forEach(function (image) {
				image.addEventListener("click", function () {
					let allImages = carousel.querySelectorAll(".vdp-ic-image");
					allImages.forEach(function (element) {
						element.classList.remove("active");
					});
					let img = this.querySelector("img");
					let src = img.getAttribute("src");
					imageCarousel.display.setAttribute("src", src);
					this.classList.add("active");
				});
			});
		}
	}
}

imageCarousel.init();
const thankYouPage = {

	doGet: function (endpoint) {
		return fetch(endpoint)
			.then(function (response) {
				const contentType = response.headers.get("content-type");
				if (contentType && contentType.indexOf("application/json") !== -1) {
					return response.json().then(function (data) {
						return JSON.parse(data);

					});
				} else {
					return response.text().then(function (html) {
						return html;
					});
				}
			});
	},

	init: function () {
		let buttons = document.querySelectorAll(".thankyou-results [data-form-element]");

		if (buttons !== null) {
			buttons.forEach(function (element) {
				element.addEventListener("click", function () {
					let buttonActive = this;
					buttonActive.classList.add("loading");
					let make = buttonActive.getAttribute("data-make");
					let model = buttonActive.getAttribute("data-model");
					let year = buttonActive.getAttribute("data-year");
					let vin = buttonActive.getAttribute("data-vin");
					let trim = buttonActive.getAttribute("data-trim");
					let offerName = buttonActive.getAttribute("data-offerName");
					let offerPosition = buttonActive.getAttribute("data-offerPosition");
					let offerType = buttonActive.getAttribute("data-offerType");
					let pagePath = buttonActive.getAttribute("data-pagePath");
					let slot = buttonActive.getAttribute("data-slot");
					let referralDataEncoded = buttonActive.getAttribute("data-referralDataEncoded");

					let firstName = store.data.firstName;
					let lastName = store.data.lastName;
					let mobile = store.data.mobile;
					let email = store.data.email;
					let zipCode = store.data.zipCode;
					let gid = store.data.gid;

					let path = "https://cars.automoblog.net/api/inventory/submittyplead?make=" + make + "&model=" + model +
						"&zipCode=" + zipCode + "&fName=" + firstName + "&lName=" + lastName +
						"&email=" + email + "&phone=" + mobile + "&gid=" + gid + "&vin=" + vin +
						"&year=" + year + "&trim=" + trim + "&offerName=" + offerName +
						"&offerPosition=" + offerPosition + "&offerType=" + offerType +
						"&pagePath=" + pagePath + "&slot=" + slot + "&referralDataEncoded=" + referralDataEncoded;

					thankYouPage.doGet(path)
						.then(function (data) {
							buttonActive.classList.remove("loading");
							buttonActive.classList.add("submitted");
							buttonActive.disabled = true;
							buttonActive.innerHTML = "Submitted";
						});
				});
			});
		}

		let legals = document.querySelectorAll("[data-legal-target]");
		legals.forEach(function (legal) {
			legal.addEventListener("click", function (e) {
				console.log("click");
				e.preventDefault();
				let target = this.getAttribute("data-legal-target");
				console.log(target);
				let element = document.getElementById(target);
				console.log(element);
				element.classList.add("active");
			});
		});

		let legalClose = document.querySelectorAll(".legal-close");
		legalClose.forEach(function (close) {
			close.addEventListener("click", function () {
				document.querySelector(".modal-container.active").classList.remove("active");
			});
		});
	}
}

thankYouPage.init();
const unsubscribe = {
    recaptchaPassed: false,
    init: function () {
        this.bindHandlers();
    },

    bindHandlers: function () {
        if (this.getForm)
            this.getForm().addEventListener('submit', (event) => {
                console.log(this.recaptchaPassed);
                if (!this.recaptchaPassed) {
                    this.getRecaptchaError().classList.remove('visually-hidden');
                    event.preventDefault();
                } else {
                    this.getRecaptchaError().classList.add('visually-hidden');
                }

                if (this.getEmail().value == "") {
                    this.getEmailError().classList.remove('visually-hidden');
                    event.preventDefault();
                } else {
                    this.getEmailError().classList.add('visually-hidden');
                }
            });
    },

    recaptchaPassedCallback: function () {
        console.log("recaptchaPassedCallback");
        unsubscribe.recaptchaPassed = true;
        unsubscribe.getRecaptchaError().classList.add('visually-hidden');
    },

    getRecaptchaError: function () {
        return document.getElementById('recaptchaError');
    },

    getForm: function () {
        return document.getElementById('unsubscribePageForm');
    },

    getEmail: function () {
        return document.getElementById('email');
    },

    getEmailError: function () {
        return document.getElementById('emailError');
    }
}

unsubscribe.init();

window.recaptchaPassedCallback = unsubscribe.recaptchaPassedCallback;
